## Задание

Реализовать программу согласно описанию. Можно использовать языки C++ или Python и 
любые библиотеки, при этом необходимо чтобы вся задача не решалась только с помощью одной 
встроенной функции (например, lib.detect_template(image, template). Сравнить качество 
работы двух вариантов реализации по точности детектирования.

Необходимо реализовать два примитивных детектора объектов на изображении, работающих с
помощью поиска эталона на входном изображении.

1. Прямой поиск одного изображения на другом (template matching)
2. Поиск ключевых точек эталона на входном изображении (например, с помощью SIFT, ORB..)


## Теория

Функция matchTemplate библиотеки OpenCV пытается найти шаблон на исходном изображении, путём скольжения
шаблона и вычисления метрики схожести

Алгоритм SIFT (Scale-invariant feature transform) был предложен Девидом Лоу в 1999 году.
Он позволяет сравнивать изображения, подвергнутые таким трансформациям как изменение
масштаба, смещение объекта на сцене, повороты камеры или объекта.

Данный алгоритм относится к группе поиска ключевых точек эталона на входном изображении. Такие алгоритмы, можно сказать,
заменяют изображение некоторой моделью — набором его ключевых точек. Особой называется такая точка изображенного объекта,
которая с большой долей вероятности будет найдена на другом изображении этого же объекта. Назовём **детектором** метод
извлечения ключевых точек из изображения. Детектор должен обеспечивать инвариантность нахождения одних и тех же
особых точек относительно преобразований изображений. Чтобы определить какая ключевая точка одного изображения
соответствует ключевой точке другого изображения используют дискрипторы. Дескриптор — идентификатор ключевой точки,
выделяющий её из остальной массы особых точек.

Преобразования, относительно которых мы бы хотели получить инвариантность:
1. смещения
2. поворот
3. масштаб (один и тот же объект может быть разных размеров на различных изображениях)
4. изменения яркости
5. изменения положения камеры

### Нахождение особых точек

Основным моментом в детектировании особых точек является построение пирамиды гауссианов (Gaussian) и разностей
гауссианов (Difference of Gaussian, DoG).

![Alt text](images/gaussian.png?raw=true "Гауссиан")

Здесь L — значение гауссиана в точке с координатами (x,y), а sigma — радиус размытия. G — гауссово ядро,
I — значение исходного изображения, * — операция свертки.

Разностью гауссианов называют изображение, полученное путем попиксельного вычитания одного гауссина
исходного изображения из гауссиана с другим радиусом размытия.

Инвариантность относительно масштаба достигается за счет нахождения ключевых точек для исходного
изображения, взятого в разных масштабах. Для этого строится пирамида гауссианов: все масштабируемое
пространство разбивается на некоторые участки — октавы, причем часть масштабируемого пространства,
занимаемого следующей октавой, в два раза больше части, занимаемой предыдущей. К тому же, при переходе
от одной октавы к другой делается ресэмплинг изображения, его размеры уменьшаются вдвое. Естественно,
что каждая октава охватывает бесконечное множество гауссианов изображения, поэтому строится только
некоторое их количество N, с определенным шагом по радиусу размытия. С тем же шагом достраиваются два
дополнительных гауссиана (всего получается N+2), выходящие за пределы октавы.

![Alt text](images/pyramid.png?raw=true "Процесс построения пирамиды гауссиан")

Будем считать точку особой, если она является локальным экстремумом разности гауссианов. Для этого
необходимо сравнить точку с 26 соседями: 8 точек на её уровне в пирамиде гауссиан и по 9 точек на
предыдущем и  следующих уровнях пирамиды. Если точка является минимум или максимумом, то она 
включается в список особы точек.

![Alt text](images/extremum.png?raw=true "Поиск точек экстремума")

Далее необходимо уточнить положение экстремума. Это делается с помощью многочлена Тейлора второго
порядка, взятого в точке вычисленного экстремума.

Затем идёт стадия фильтрации точек: из списка особых точек удаляются те, которые либо имеют низкую
контрастность относительно соседних точек, либо сконцентрированы на границах объектов. Для каждой
точки считается несколько специальных функций, по значениям которых решается отбрасывать ли точку.

Для каждой ключевой точки вычисляется особая величина – направление ключевой 
точки. Это необходимо для обеспечения инвариантности алгоритма относительно 
поворота объекта. Направление ключевой точки – это угол из интервала \[0; 359)
точки может быть несколько направлений. Для расчёта направления берётся несколько 
соседних точек и считаются их градиенты. Чаще всего в качестве соседей берётся 
квадрат 5 на 5 точек (окно), центром которого является выбранная ключевая точка. Для 
каждой точки считается её градиент и направление градиента.

Конечное направление ключевой точки находится из гистограммы направлений 
ключевых точек окна. В гистограмме 36 компонент, которые равномерно покрывают 
весь интервал в 360 градусов. Направление ключевой точки лежит в промежутке, покрываемом максимальной 
компонентой гистограммы. Если в гистограмме есть ещё компоненты с величинами не 
меньше 80% от максимальной величины, то они считаются дополнительными 
направлениями ключевой точки.

### Построение дескрипторов

На этой стадии алгоритма вычисляются значения дескрипторов. Перед вычислением дескриптора выбирается,
сколько точек вокруг ключевой будет учитываться (чаще всего учитываются 16 точек). Далее для каждой
точки строится гистограмма, аналогичная гистограмме ориентации ключевой точки, но с меньшим числом
компонент (8 компонент вместо 36). Далее формируется вектор из 128 (16 гистограмм с восемью компонентами
в каждой) чисел. Этот вектор и есть дескриптор SIFT.

![Alt text](images/keypoint_descriptor_128.png?raw=true "Дескриптор размерности 128")

<br /> <br />

![Alt text](images/keypoint_descriptor.png?raw=true "Получение дескриптора размерности 32")

### Сравнивание дескрипторов SIFT для разных изображений

Сравнивание происходит по методу, предложенному Девидом Лоу. Для каждого дескриптора _D_ из изображения
_I_ происходит поиск двух ближайших дескрипторов _U1_ и _U2_. За расстояние между дескрипторами принимается
Евклидова метрика между дескрипторами _U1_ и _U2_. Считается отношение длин _U2_ к _U1_, и если оно больше
некого порога, то сравнение считается верным и дескрипторы _D_ и _U1_ считаются совпадающими.

## Реализация

Программа считывает исходное изображение и шаблон. Поскольку оба используемых в работе алгоритма работают
с чёрно-белыми изображениями, преобразуем их с учётом этого ограничения.

Реализация с функцией match_template ищет шаблон на монохромном изображении. При успехе мы получаем координаты окна,
которое отрисовываем на цветном исходнике.

После применения алгоритма SIFT мы получаем массив дескрипторов и ключевых точек для изображения. Применяем
алгоритма для исходного и шаблонного изображений. Затем получим разности между дескриторами путём использования
метода match класса BFMatcher (Brute Force Matcher). Возбмём n ближайших дескрипторов. По ним определяем точки
на исходном и шаблонном изображении, которые "похожи" друг надруга сильнее всего. 

### Исходные данные

Было сделано 10 фотографии красной кружки с разных ракурсов и разном освещением. Из 3 фотографий было вырезано
изображение объекта. Всего 13 фотографий. В качестве шаблонов выбрано 10 изображений (включая 3 "вырезанных"),
а исходных 3. Всего 30 возможных комбинаций для поиска шаблонов.

Реализация с matchTemplate хорошо себя показывает при поиске шаблона который был вырезан из исходной фотографии.
В других случаях алгоритму не удаётся достичь приемлемого результата.

Примеры:

![Alt text](images/results/MT_merge.jpg?raw=true "Результаты алгоритма match template")

<br /> <br />

Алгоритм SIFT демонстрирует значительное превосходство по качеству детекции по сравнению с matchTemplate. Тем не менее
иногда он концентрируется не наглавном объекте сцены, а на фоне.

Хорошие результаты:

![Alt text](images/results/SIFT_good_merge.jpg?raw=true "Результаты алгоритма SIFT")

<br /> <br />

Сомнительные результаты:

![Alt text](images/results/SIFT_bad_merge.jpg?raw=true "Результаты алгоритма SIFT")

<br /> <br />

В итоге детектирование с использованием matchTemplate дало 7 хороших результатов из 30, а алгоритм SIFT
смог хорошо сдетектировать около 17 фотографий (при этом объект кружка был найден на каждой фотографии,
разница заключается в части сдетектированного объекта и затронутого фона)

## Выводы

В результате проделанной работы было реализовано две функции детектирования объектов с применением алгоритмов
matchTemplate и SIFT. По результатам можно рекомендовать использовать алгоритм SIFT для большинства случаев, однако
стоит заметить, что его качество можно значительно улучшить, если шаблон будет содержать максимально приближенный
детектируемый объект.
